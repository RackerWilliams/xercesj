<!-- DTD for XML Schemas: Part 1: Structures -->
<!-- $Id$ -->
<!-- Note this DTD is NOT the normative structures DTD - - the
     prose copy in the structures REC is the normative version (which
     shouldn't differ from this one except for this comment and entity
     expansions, but just in case -->
<!ENTITY % versionEntities SYSTEM "versionInfo.ent">
%versionEntities; <!-- get path and date entities -->

<!-- The the datatype element and its components
     are defined in XML Schema: Part 2: Datatypes -->
<!-- Note %p is defined in datatypes.dtd -->
<!ENTITY % xs-datatypes PUBLIC 'datatypes'
                     "http://www.w3.org/TR/1999/WD-xmlschema-2-19991217/datatypes.dtd" >
%xs-datatypes;

<!ENTITY % s ''> <!-- if %p is defined (e.g. as foo:) then you must
                      also define %s as the suffix for the appropriate
                      namespace declaration (e.g. :foo) -->
<!ENTITY % nds 'xmlns%s;'>

<!-- Define all the element names, with optional prefix -->
<!ENTITY % schema "%p;schema">
<!ENTITY % type "%p;type">
<!ENTITY % restrictions "%p;restrictions">
<!ENTITY % element "%p;element">
<!ENTITY % unique "%p;unique">
<!ENTITY % key "%p;key">
<!ENTITY % keyref "%p;keyref">
<!ENTITY % selector "%p;selector">
<!ENTITY % field "%p;field">
<!ENTITY % group "%p;group">
<!ENTITY % any "%p;any">
<!ENTITY % anyAttribute "%p;anyAttribute">
<!ENTITY % sic "%p;sic">
<!ENTITY % attribute "%p;attribute">
<!ENTITY % attributeGroup "%p;attributeGroup">
<!ENTITY % include "%p;include">
<!ENTITY % import "%p;import">
<!ENTITY % notation "%p;notation">

<!-- the duplication below is to produce an unambiguous content model
     which allows annotation everywhere -->
<!-- This has the unfortunate consequence of disallowing a schema with
     only import/includes, this should be fixed -->
<!ELEMENT %schema; ((%include; | %import; | %annotation;)*,
                    (%datatype; | %type;
                     | %element;
                     | %attributeGroup; | %group;
                     | %notation; ),
                    (%annotation;
                     | %datatype; | %type;
                     | %element;
                     | %attributeGroup; | %group;
                     | %notation; 
                     | %unique; | %key; | %keyref; )* )>
<!ATTLIST %schema;
                 targetNamespace    %URI;           #IMPLIED
                 version            CDATA           #IMPLIED
                 %nds;              %URI;           #FIXED '&XMLSchemaNS;'
                 finalDefault       %derivationSet; ''
                 exactDefault       %exactSet;      ''>
<!-- Note the xmlns declaration is NOT in the Schema for Schemas,
     because at the Infoset level where schemas operate,
     xmlns(:prefix) is NOT an attribute! -->
 

<!-- a type is a named content type specification which allows attribute
     declarations-->
<!-- -->

<!ELEMENT %type; ((%annotation;)?,
                 (%restrictions; |
                  ((%element;| %group;| %any;)*,
                   (%attribute;| %attributeGroup;)*,
                   (%anyAttribute;)?)))>

<!ATTLIST %type;
          name      %NCName;                        #IMPLIED
          content   (textOnly|mixed|elementOnly|empty) #IMPLIED
          abstract  %boolean;                       'false'
          final     %derivationSet;                 ''
          exact     %derivationSet;                 ''
          derivedBy %derivationChoice;              #IMPLIED 
          source    %QName;                         #IMPLIED>

<!-- restrictions iff derivedBy='restriction' -->
<!-- (element|group|any) only if content=mixed or =elementOnly
     and NO derivedBy at all, i.e. a root type -->
<!-- content defaults to source's if there is a complex source,
     textonly if there's a simple source,
     'mixed' if no source (because that's the urType's content)
             and no content daughters,
     'elementOnly' otherwise --> 
<!-- should we replace content='empty' with content='elementOnly'
     final='#all' plus no content? -->

<!-- If one top-level group, that IS the content model, otherwise
     an implicit group obtains.
     This is
       <group order='seq' minOccurs='1' maxOccurs='1'>
     unless content='mixed', in which case it's
       <group order='choice' minOccurs='0' maxOccurs='*'> -->

<!-- If anyAttribute appears in one or more referenced attributeGroups
     and/or explicitly, the intersection of the permissions is used -->

<!-- A text-only type with no attributes differs from a datatype with
     the same source qualified the same way in regard to the impact on
     attributes of anyAttribute -->

<!ELEMENT %restrictions; ((%annotation;)?,
                        ((%facet;)*|
                        (%element;| %group;| %any;| %sic;)*),
                        (%attribute;| %attributeGroup;)*,
                        (%anyAttribute;)?)>

<!-- this contains material for restricting components of inherited types -->
<!-- (element|group|any|sic) allowed only if source refers to an
     elementOnly or mixed type, the sequence and GI must match point for
     point with (an initial sub-sequence of) the content model of
     the basetype, restricting in each case, except that 'sic' is
     allowed to "copy through" a single particle.
     Only the top-level content model can be restricted,
     e.g. the content model of an anonymous embedded 'type' within
     an 'element' particle cannot be restricted piecemeal. -->
<!-- attributes to be restricted are identified by name, without order 
     constraints.
     Attributes incorporated into sources via attributeGroups may be
     restricted by name. -->
<!-- If anyAttribute appears in one or more referenced attributeGroups
     and/or explicitly, the intersection of the permissions with the
     inherited permission (which must exist) is used -->

<!-- facets are allowed only if source refers to a textonly type -->

<!-- an element is declared by either:
 a name and a type (either nested or referenced via the type attribute)
or:
 a ref to an existing element declaration -->

<!ELEMENT %element; ((%annotation;)?, (%type;| %datatype;)?,
                     (%unique; | %key; | %keyref;)*)>
<!-- type or datatype only if no type|ref attribute -->
<!-- ref not allowed at top level -->
<!ATTLIST %element;
            name        %NCName;               #IMPLIED
            ref         %QName;                #IMPLIED
            type        %QName;                #IMPLIED
            minOccurs   %non-negative-integer; '1'
            maxOccurs   CDATA                  #IMPLIED
            nullable    %boolean;              'false'
            equivClass  %QName;                #IMPLIED
            abstract    %boolean;              'false'
            final       %boolean;              'false'
            exact       %exactSet;             ''
            default     CDATA                  #IMPLIED
            fixed       CDATA                  #IMPLIED>
<!-- type and ref are mutually exclusive.
     name and ref are mutually exculsive, one is required -->
<!-- In the absence of type AND ref, type defaults to type of
     equivClass, if any, else the ur-type, i.e. unconstrained -->
<!-- maxOccurs defaults to 1 or minOccurs, whichever is greater -->
<!-- default and fixed are mutually exclusive -->

<!ELEMENT %group; ((%annotation;)?, (%element;| %group;| %any;)*)>
<!ATTLIST %group;
            minOccurs   %non-negative-integer; '1'
            maxOccurs   CDATA                  #IMPLIED
            order       (choice|seq|all)       'seq'
            name        %NCName;               #IMPLIED
            ref         %QName;                #IMPLIED>


<!-- an anonymous grouping in a model, or
     a top-level named group definition, or a reference to same -->

<!-- Note that if order is 'all', group is not allowed inside.
     If order is 'all' THIS group must be alone (or referenced alone) at
     the top level of a content model -->
<!-- If order is 'all', minOccurs==maxOccurs==1 on element/any inside -->
<!-- Should allow minOccurs=0 inside order='all' . . . -->

<!ELEMENT %any; EMPTY>
<!ATTLIST %any;
            namespace    CDATA                  '##any'
            minOccurs    %non-negative-integer; '1'
            maxOccurs    CDATA                  #IMPLIED>

<!-- namespace is interpreted as follows:
                  ##any      - - any non-conflicting WFXML at all

                  ##other    - - any non-conflicting WFXML from namespace other
                                  than targetNamespace

                  one or     - - any non-conflicting WFXML from
                  more URI        the listed namespaces
                  references

                  ##targetNamespace may appear in the above list, with the
                   obvious meaning -->

<!ELEMENT %anyAttribute; EMPTY>
<!ATTLIST %anyAttribute;
            namespace    CDATA   '##any'>
<!-- namespace is interpreted as for 'any' above -->


<!-- for use inside basetype to copy down corresponding content
     model particle from the basetype's content model -->
<!ELEMENT %sic; EMPTY>

<!ELEMENT %attribute; ((%annotation;)?, (%datatype;)?)>
<!ATTLIST %attribute;
          name      %NCName;      #REQUIRED
          type      %QName;       #IMPLIED
          maxOccurs (0|1)         '1'
          minOccurs (0|1)         '0'
          default   CDATA         #IMPLIED
          fixed     CDATA         #IMPLIED>
<!-- default and fixed are mutually exclusive -->
<!-- type attr and datatype content are mutually exclusive -->

<!-- an attributeGroup is a named collection of attribute decls, or a
     reference thereto -->
<!ELEMENT %attributeGroup; ((%annotation;)?,
                       (%attribute; | %attributeGroup;)*,
                       (%anyAttribute;)?) >
<!ATTLIST %attributeGroup;
                 name       %NCName;       #IMPLIED
                 ref        %QName;        #IMPLIED>

<!-- ref iff no content, no name.  ref iff not top level -->

<!-- better reference mechanisms -->
<!ELEMENT %unique; (%selector;, (%field;)+)>
<!ATTLIST %unique; name     %NCName;       #REQUIRED>

<!ELEMENT %key;    (%selector;, (%field;)+)>
<!ATTLIST %key;    name     %NCName;       #REQUIRED>

<!ELEMENT %keyref; (%selector;, (%field;)+)>
<!ATTLIST %keyref;
                   name     %NCName;       #REQUIRED
                   refer    %QName;        #REQUIRED>

<!ELEMENT %selector; (#PCDATA)>
<!ELEMENT %field; (#PCDATA)>

<!-- Schema combination mechanisms -->
<!ELEMENT %include; EMPTY>
<!ATTLIST %include; schemaLocation %URI; #REQUIRED>

<!ELEMENT %import; EMPTY>
<!ATTLIST %import; namespace      %URI; #REQUIRED
                    schemaLocation %URI; #IMPLIED>

<!ELEMENT %notation; EMPTY>
<!ATTLIST %notation;
                 name        %NCName;    #REQUIRED
                 public      CDATA       #REQUIRED
                 system      %URI;       #IMPLIED>

<!NOTATION XMLSchemaStructures PUBLIC 'structures'
           '&XSP1.URI;.xsd' >
<!NOTATION XML PUBLIC 'REC-xml-1998-0210'
               'http://www.w3.org/TR/1998/REC-xml-19980210' >
