<?xml version="1.0" standalone="no"?>
<!DOCTYPE faqs SYSTEM "sbk:/style/dtd/faqs.dtd">

<faqs title="Writing Application FAQs">
	<faq title="Constructing a Parser">
		<q>How do I construct a parser in &javaparsername;?</q>
		<a><p>
There are two ways the parser classes can be
	  instantiated: The first way is to <em>create a string</em>
	  containing the fully qualified name of the parser class. Pass
	  this string to the <code>org.xml.sax.helpers.ParserFactory.makeParser()</code>
	  method to instantiate it. This method is useful if your application will need to switch between different parser configurations. The code snippet shown below is using this method to instantiate a DOMParser.</p> 

	   <source>
import org.xml.sax.Parser;
import org.xml.sax.helpers.ParserFactory; 
import org.apache.xerces.parsers.DOMParser;
import org.w3c.dom.Document;
import org.xml.sax.SAXException;
import java.io.IOException; 

  ...

String parserClass = &quot;org.apache.xerces.parsers.DOMParser&quot;;

String xmlFile = &quot;file:///Xerces-J/data/personal.xml&quot;; 

Parser parser = ParserFactory.makeParser(parserClass);

try {
    parser.parse(xmlFile);
} catch (SAXException se) {
    se.printStackTrace();
} catch (IOException ioe) {
	ioe.printStackTrace();
}
// The next line is only for DOM Parsers

Document doc = ((DOMParser) parser).getDocument(); 

  ...
	 </source>

	 <p>The second way to instantiate a parser class is to <em>explicitly
	 instantiate</em> the parser class, as shown in this example,
	 which is creating a DOM Parser. Use this way when you know
	 exactly which parser configuration you need, and you are sure
	 that you will not need to switch configurations.</p>

	 <source>
import org.apache.xerces.parsers.DOMParser;
import org.w3c.dom.Document;
import org.xml.sax.SAXException;
import java.io.IOException;

  ...

String xmlFile = &quot;file:///Xerces-J/data/personal.xml&quot;; 

DOMParser parser = new DOMParser();

try {
    parser.parse(xmlFile);

} catch (SAXException se) {
    se.printStackTrace();
} catch (IOException ioe) {
    ioe.printStackTrace();
}
// The next line is only for DOM Parsers
Document doc = parser.getDocument();

  ...
	 </source>

	<p>Once you have the Document object, you can call any method on it as defined by the DOM specification.</p>
   </a>
	</faq>
	<faq title="Creating a DOM Parser">
		<q>How do I create a DOM parser?</q>
        <a><p>Use one of the methods in the question above, and use 
		<code>org.apache.xerces.parsers.DOMParser</code> as the name of the class. </p>
		<p>To access the DOM tree, you can call the
		<code>getDocument()</code> method on the parser instance.</p> 
		</a>
	</faq>
	<faq title="Creating a SAX Parser">
		<q>How do I create a SAX parser?</q>
		<a><p>Use one of the methods in the question above, and use 
		<code>org.apache.xerces.parsers.SAXParser</code> as the name of the class. </p>
		<p>Once you have the parser instance, you can use the standard SAX 
		methods to set the various handlers provided by SAX. </p>
		</a>
	</faq>
	<faq title="Controlling parser options">
		<q>How do I control the various parser options?</q>
		<a><p>For this release, all of the parser control API's have
		been switched over to the SAX2 Configurable interface.  This
		provide a uniform and extensible mechanism for setting and
		querying parser options.  Here are guides to the set of
		available <link idref="features">features</link> and
		<link idref="properties">properties</link>.</p>
		</a>
	</faq>
	<faq title="Using lazy DOM">
		<q>How do I use the lazy evaluating DOM implementation?</q>
		<a><p>The DOM parser class
		<code>org.apache.xerces.parsers.DOMParser</code> now uses a DOM
		implementation that can take advantage of lazy evaluation to
		improve performance.  The setNodeExpansion call on these
		classes controls the use of lazy evaluation. There are two
		values for the argument to setNodeExpansion: FULL and
		DEFERRED(the default). </p> 
	    <p>If node expansion is set to FULL, then the DOM classes
	    behave as they always have, creating all nodes in the DOM tree
	    by the end of parsing.</p> 

	    <p>If node expansion is set to DEFERRED, nodes in the DOM tree
	    are only created when they are accessed. This means that a
	    call to getDocument will return a DOM tree that consists only
	    of the Document node. When your program accesses a child of
	    Document, the children of the Document node will be
	    created. All the immediate children of a Node are created when
	    any of that Node's children are accessed. This shortens the
	    time it takes to parse an XML file and create a DOM tree. This
	    also increases the time it takes to access a node that has not
	    been created. After nodes have been created, they are cached,
	    so this overhead only occurs on the first access to a
	    Node. </p> 
		</a>
	</faq>
	<faq title="Handling Errors">
		<q>How do handle errors?</q>
		<a><p>When you create a parser instance, the default error handler does nothing. 
		This means that your program will fail silently when it encounters an error. 
		You should register an error handler with the parser by supplying a class 
		which implements the <code>org.xml.sax.ErrorHandler</code>
		interface. This is true regardless of whether your parser is a
		DOM based or SAX based parser.</p>
		</a>
	</faq>
	<faq title="Controlling Entity Representation">
		<q>How can I control the way that entities are represented in
		the DOM?</q>
		<a><p>
        The feature <code>http://apache.org/xml/features/dom/create-entity-ref-nodes</code>
        controls how entities appear in the DOM tree. When this
        feature is set to true (the default), an occurance of an
        entity reference in the XML document will be represented by a
        subtree with an EntityReference node at the root whose
        children represent the entity expansion.</p>

    	<p>If the property is false, an entity reference in the XML
    	document is represented by only the nodes that represent the
    	entity expansion.</p> 

        <p>In either case, the entity expansion will be a DOM tree
        representing the structure of the entity expansion, not a text
        node containing the entity expansion as text.</p>
		</a>
	</faq>
	<faq title="Non-Validating">
		<q>Why does "non-validating" not mean "well-formedness checking only"?</q>
		<a><p>Using a "non-validating" parser does not mean that only well-formedness 
        checking is done! There are still many things that the XML specification 
		requires of the parser, including entity substitution, defaulting of 
		attribute values, and attribute normalization.</p>
        <p>This table describes what "non-validating" really means for &javaparsername; parsers. 
		In this table, "no DTD" means no internal or external DTD subset is present.</p>
		
        <table>
			<tr><tn/>
				<th colspan="2">non-validating parsers</th>
				<th colspan="2">validating parsers</th>
          	</tr>
          	<tr>
				<tn/>
				<th>DTD present</th>
				<th>no DTD</th>
				<th>DTD present</th>
				<th>no DTD</th>
          	</tr>
          	<tr>
				<th>DTD is read</th>
				<td>Yes</td>
				<td>No</td>
				<td>Yes</td>
				<td>Error</td>
          	</tr>
          	<tr>
				<th>entity substitution</th>
				<td>Yes</td>
				<td>No</td>
				<td>Yest</td>
				<td>Error</td>
          	</tr>
          	<tr>
				<th>defaulting of attributes</th>
				<td>Yes</td>
				<td>No</td>
				<td>Yes</td>
				<td>Error</td>
          	</tr>
          	<tr>
				<th>attribute normalization</th>
				<td>Yes</td>
				<td>No</td>
				<td>Yes</td>
				<td>Error</td>
          	</tr>
          	<tr>
				<th>checking against model</th>
				<td>No</td>
				<td>No</td>
				<td>Yes</td>
				<td>Error</td>
          	</tr>
        </table>
		</a>
	</faq>
	<faq title="Associating Data with a Node">
		<q>How do associate my own data with a node in the DOM tree?</q>
		<a><p>The class <code>org.apache.xerces.dom.NodeImpl</code> provides a 
			<code>void setUserData(Object o)</code> and an <code>Object getUserData()</code>
         	method that you can use to attach any object to a node in the DOM tree.</p>
		</a>
	</faq>
	<faq title="Parsing Several Documents">
		<q>How do I more efficiently parse several documents sharing a common DTD?</q>
		<a>	<p>DTDs are not currently cached by the parser. The common DTD, since it is 
        	specified in each XML document, will be re-parsed once for each document.</p>
			<p>However, there are things that you can do now, to make the process of 
			reading DTD's more efficient:</p>
        	<ul>
          		<li>keep your DTD and DTD references local</li>
          		<li>use internal DTD subsets, if possible</li>
          		<li>load files from server to local client before parsing</li>
          		<li>Cache document files into a local client cache. You should do an 
					HTTP header request to check whether the document has changed, 
					before accessing it over the network.</li>
          		<li>Do not reference an external DTD or internal DTD subset at all. 
					In this case, no DTD will be read.</li>
        	</ul>
		</a>
	</faq>
    <faq title="How do access the DOM Level 2 functionality">
        <q>How do I access the DOM Level 2 functionality</q>
        <a><p>Because the DOM Level 2 spec is not frozen yet, the interfaces
              for DOM Level 2 can be found in the package org.apache.xerces.domx
              and its subpackages.</p></a>
    </faq>
	<faq title="How do I read data from a stream as it arrives?">
		<q>How do I read data from a stream as it arrives?</q>
		<a><p>For performance reasons, all the standard Xerces processing
		uses readers which buffer the input.  In order to read data
		from a stream as it arrives, you need to instruct Xerces to
		use the <code>StreamingCharReader</code> class as its reader.
		To do this, create a subclass of
		<code>org.apache.xerces.readers.DefaultReaderFactory</code>
		and override <code>createCharReader</code> and
		<code>createUTF8Reader</code> as shown below.
		</p>
		<source>
public class StreamingCharFactory extends org.apache.xerces.readers.DefaultReaderFactory {
    public XMLEntityHandler.EntityReader createCharReader(XMLEntityHandler entityHandler,
                                                          XMLErrorReporter errorReporter,
                                                          boolean sendCharDataAsCharArray,
                                                          Reader reader,
                                                          StringPool stringPool) throws Exception
            {
                return new org.apache.xerces.readers.StreamingCharReader(entityHandler, errorReporter, sendCharDataAsCharArray, reader, stringPool);
            }

    public XMLEntityHandler.EntityReader createUTF8Reader(XMLEntityHandler entityHandler,
                                                          XMLErrorReporter errorReporter,
                                                          boolean sendCharDataAsCharArray,
                                                          InputStream data,
                                                          StringPool stringPool) throws Exception
            {
                XMLEntityHandler.EntityReader reader;
                reader = new org.apache.xerces.readers.StreamingCharReader(entityHandler, errorReporter, sendCharDataAsCharArray, new InputStreamReader(data, "UTF8"), stringPool);
                return reader;
            }

}
		</source>
		<p>
	    In your program, after you instantiate a parser class, replace
	    the <code>DefaultReaderFactory</code> with <code>StreamingCharFactory</code>, and be
	    sure to wrap the <code>InputStream</code> that you are reading
	    from with an <code>InputStreamReader</code>.
		</p>
	    <source>
InputStream in = ... ;
SAXParser p = new SAXParser();
DocumentHandler h = ... ;
// set the correct reader factory
p.setReaderFactory(((StreamingSAXClient)h).new StreamingCharFactory());
p.setDocumentHandler(h);

// be sure to wrap the input stream in an InputStreamReader.
p.parse(new InputSource(new InputStreamReader(in)));
		</source>
		</a>
	</faq>
</faqs>
